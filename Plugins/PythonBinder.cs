using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using Python.Runtime;
using Unison.Extensions;
#if UNITY_EDITOR
using UnityEngine;

#elif GODOT
using Godot;
#endif


namespace Unison.Bind
{
    /**
     * <summary>
     * 指定namespace.class以下を取得
     * https://mitosuya.net/execute-all-class-in-namespace
     * </summary>
     */
    public class PythonBinder
    {
        private static CodeNamespace nameSpace;
        private static Dictionary<Action<string>, string> _functions;

        #region Comment

        private const string _template = @"
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Date Time: YMD
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
        ";

        #endregion

        /// <summary>
        /// CodeDOM Structure
        /// </summary>
        /// <param name="typeName"></param>
        /// <returns></returns>
        public static PythonBinder Gen()
        {
            #region File Header

            nameSpace = new CodeNamespace(name: "Client");
            var time = DateTime.Now.ToString("yyyy/MM/dd");
            var comment = new CodeCommentStatement(new CodeComment(_template.Replace("YMD", time)));
            nameSpace.Comments.Add(comment);
            nameSpace.Imports.Add(new CodeNamespaceImport(nameSpace: "System"));

            var mainClass = new CodeTypeDeclaration(name: "Runtime");
#if UNITY_EDITOR
            nameSpace.Imports.Add(new CodeNamespaceImport(nameSpace: "UnityEngine"));
            mainClass.BaseTypes.Add(new CodeTypeReference(typeof(MonoBehaviour)));
#elif GODOT
            nameSpace.Imports.Add(new CodeNamespaceImport(nameSpace: "Godot"));
            mainClass.BaseTypes.Add(new CodeTypeReference(typeof(Node)));
#endif

            #endregion

            var assemblies = new HashSet<Assembly>
            {
#if UNITY_EDITOR
                Assembly.Load("Assembly-CSharp"), Assembly.Load("Assembly-CSharp-Editor")
#elif GODOT
                Assembly.GetExecutingAssembly()
#endif
            };

            foreach (var assembly in assemblies)
            {
                foreach (var typeName in assembly.GetExportedTypes())
                {
                    #region Fields

                    var fields =
                        typeName.GetFields(BindingFlags.GetField | BindingFlags.Public | BindingFlags.Instance);
                    foreach (var field in fields)
                    {
                        var variable = new CodeMemberField(field.FieldType.Name, field.Name);
#if UNITY_EDITOR
                        var codeAttrDecl = new CodeAttributeDeclaration(
                            "SerializeField",
                            new CodeAttributeArgument(new CodePrimitiveExpression(false)));
                        variable.CustomAttributes.Add(codeAttrDecl);
#elif GODOT
                        var codeAttrDecl = new CodeAttributeDeclaration(
                            "Export",
                            new CodeAttributeArgument(new CodePrimitiveExpression(false)));
                        variable.CustomAttributes.Add(codeAttrDecl);
#endif
                        mainClass.Members.Add(variable);
                    }

                    #endregion

                    #region Method

                    var methods = typeName.GetMethods(BindingFlags.Public | BindingFlags.NonPublic |
                                                      BindingFlags.Instance | BindingFlags.Static |
                                                      BindingFlags.DeclaredOnly);
                    foreach (var method in methods)
                    {
                        foreach (var attribute in method.GetCustomAttributes(typeof(PyRPCAttribute), false))
                        {
                            if (!(attribute is PyRPCAttribute consoleMethod)) continue;

                            // TODO: Play, Stop, Goto などのラッパー登録
                            Register(consoleMethod.Command, "", method);

                            var mainMethod = new CodeMemberMethod
                            {
                                ReturnType = new CodeTypeReference(method.ReturnType),
                                Attributes = MemberAttributes.Public | MemberAttributes.Final,
                                Name = method.Name
                            };
#if GODOT
                            // [Signal]
                            // public delegate void Hit();
                            var codeAttrDecl = new CodeAttributeDeclaration(
                                "Signal",
                                new CodeAttributeArgument(new CodePrimitiveExpression(false)));
                            mainMethod.CustomAttributes.Add(codeAttrDecl);
#endif
                            CodeExpression target;
                            if ((method.Attributes & MethodAttributes.Static) != 0)
                                target = new CodeSnippetExpression(typeName.FullName);
                            else
                                target = new CodeObjectCreateExpression(typeName.FullName);

                            var invoke = new CodeMethodInvokeExpression(
                                targetObject: target, methodName: method.Name
                            );

                            foreach (var p in method.GetParameters())
                            {
                                invoke.Parameters.Add(new CodeArgumentReferenceExpression(p.Name));
                                var exp = new CodeParameterDeclarationExpression(p.ParameterType, p.Name);
                                mainMethod.Parameters.Add(exp);
                            }

                            if (method.ReturnType.Name != "Void")
                                mainMethod.Statements.Add(new CodeMethodReturnStatement(invoke));
                            else
                                mainMethod.Statements.Add(invoke);

                            mainClass.Members.Add(mainMethod);
                        }
                    }

                    #endregion
                }
            }

            return new PythonBinder();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Dictionary<Action<string>, string></returns>
        public Dictionary<Action<string>, string> Commands()
        {
            return _functions;
        }

        /// <summary>
        /// CodeDOM to Assembly
        /// </summary>
        /// <param name="fileName"></param>
        public void Compile(string fileName)
        {
            if (fileName.EndsWith(".cs"))
            {
                ToCode(fileName);
                return;
            }

            var compileParameters = new CompilerParameters
            {
                OutputAssembly = fileName,
                CompilerOptions = "/optimize+ /target:library /unsafe"
            };

            var codeCompileUnit = new CodeCompileUnit();
#if UNITY_EDITOR
            codeCompileUnit.ReferencedAssemblies.Add("UnityEngine.dll");
            codeCompileUnit.ReferencedAssemblies.Add("UnityEditor.dll");
#elif GODOT
            codeCompileUnit.ReferencedAssemblies.Add("GodotSharp.dll");
#endif
            codeCompileUnit.Namespaces.Add(nameSpace);

            var snippets = new CodeCompileUnit[] { };
            snippets.SetValue(codeCompileUnit, 0);

            for (var i = 1; i < AppDomain.CurrentDomain.GetAssemblies().Length; i++)
            {
                var file = AppDomain.CurrentDomain.GetAssemblies()[i];
                var fstring = File.OpenText(file.Location);
                var unit = CodeDomProvider.CreateProvider("C#").Parse(fstring);
                snippets.SetValue(unit, i);
                fstring.Close();
            }

            var result = CodeDomProvider.CreateProvider("C#")
                .CompileAssemblyFromDom(compileParameters, compilationUnits: snippets);

            foreach (var str in result.Output)
            {
                Console.WriteLine(str);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="command"></param>
        /// <param name="description"></param>
        /// <param name="method"></param>
        private static void Register(string command, string description, MethodInfo method)
        {
            Action<string> action;

            if (method.GetType() == typeof(PyObject))
                action = method as dynamic;
            else
                action = (Action<string>) Delegate.CreateDelegate(typeof(Action<string>), method);

            _functions.Add(action, command);
        }

        /// <summary>
        /// CodeDOM to C#
        /// </summary>
        /// <param name="fileName"></param>
        /// <param name="type"></param>
        private void ToCode(string fileName, string type = "C#")
        {
            var codeText = new StringBuilder();
            using (var codeWriter = new StringWriter(codeText))
            {
                var compilerOptions = new CodeGeneratorOptions
                {
                    IndentString = "    ", BracingStyle = type
                };
                CodeDomProvider.CreateProvider(type)
                    .GenerateCodeFromNamespace(nameSpace, codeWriter, compilerOptions);
            }

            using (var writer = new StreamWriter(fileName))
            {
                writer.Write(codeText);
            }
        }
    }
}